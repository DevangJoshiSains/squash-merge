from __future__ import with_statement

import copy
import logging
import os
import re
import shutil
import subprocess
import sys
import tempfile
from typing import List, Tuple

from aspire_helpers.constants import (
    GIT_DIFF_ON_BRANCHES,
    GIT_DIFF_ON_SQUASH,
    GIT_SHOW_COMMAND,
    EnvVars,
    generate_role_name,
    get_common_var,
)
from aspire_helpers.helper_functions import read_file, read_sql
from aspire_helpers.sf_connector import call_snowflake

# def get_diff_command(deploy_mode:str = 'branch_diff'):
#
#   deploy_mode = os.environ['deploy_mode']
#    if deploy_mode == 'squash_diff':
#        command =


def get_object_type_from_sql(sql: str) -> str:
    search_object = re.search(
        r"(?:^|\W)(PROCEDURE|TASK|TABLE|VIEW|SEQUENCE|STREAM|TAG)(?:$|\W)",
        sql,
        flags=re.IGNORECASE,
    )
    if search_object:
        return search_object.group(1)

    else:
        return None


def get_sql_statements(diff_results: List[str]) -> List[str]:
    """
    For each file in diff_results...
        1. Extract SQL code;
        2. Remove semi colons and trailing empty string list artefacts;
        3. Add cleaned SQL code to Snowflake Lambda config list.
    :param diff_results: list[str]
    :return: list[str]
    """
    database = get_common_var(EnvVars.DATABASE)
    deploy_sql = []
    for script in diff_results:
        clean_sql_script = read_file(script)
        object_type = get_object_type_from_sql(clean_sql_script)

        if object_type == "TASK":
            clean_sql_script = clean_sql_script.replace("{database}", database)
            deploy_sql.append(clean_sql_script)
        elif object_type == "PROCEDURE":
            deploy_sql.append(clean_sql_script)
        else:
            clean_sql_script = read_file(script).split(";")[0:-1]
            deploy_sql.extend(clean_sql_script)
    return clean_sql(deploy_sql)


def clean_sql(deploy_sql: List[str]) -> List[str]:
    """
    For each query in deploy_sql it cleans SQL code
    by stripping newlines and by adding end-of-line
    character ";" if code line does not end with it.
    :param deploy_sql: list[str]
    :return deploy_clean_sql: list[str]
    """
    cleaned_deploy_sql = [
        sql_command.strip("\n") + ";"
        if sql_command[-1] != ";"
        else sql_command.strip("\n")
        for sql_command in deploy_sql
    ]

    return cleaned_deploy_sql


def execute(command: str, multi_statement: bool = False) -> List[str]:
    """
    Executes bash code passed in through `command` argument.
    Output is returned as List[str], to facilitate multiline results.
    :param command: str
    :param multi_statement: bool
    :return: clean_output: List[str]
    """
    logging.info(f"ü§ñ Executing command [{command}]")

    if not multi_statement:
        command = command.split()

    process = subprocess.Popen(command, stdout=subprocess.PIPE, shell=multi_statement)
    output, error = process.communicate()
    clean_output = list(filter(None, output.decode("utf-8").split("\n")))

    return clean_output


def execute_git_diff(directory: str, use_main: bool = False) -> List[str]:
    """
    If given directory exists, retrieve any Git diffs
    that may be associated with that directory.
    :return diff_results: list[str]
    """
    if not os.path.exists(directory):
        # Fail loudly if the directory does not exist
        logging.exception(f"üí• Directory [{directory}] does not exist - exiting.")
        raise FileNotFoundError("Directory not found" + directory)

    if use_main:
        diff_command = GIT_DIFF_ON_SQUASH.format(directory=directory)
    else:
        diff_command = GIT_DIFF_ON_BRANCHES.format(directory=directory)

    diff_results = execute(diff_command)
    if diff_results:
        return diff_results

    logging.info(f"üí• No files returned from diff in [{directory}].")
    return []


def get_stateless_object_sql(use_main: bool = False) -> Tuple:
    """
    Identify and retrieve stateless objects (such as procedures and views)
    sql code from main branch.
    """
    DDL_DIR = get_common_var(EnvVars.DDL_DIR)
    stateless_rollback_results = []
    sqldbm_diff_results = execute_git_diff(DDL_DIR, use_main=use_main)
    temp_dir_path = tempfile.mkdtemp()
    for result in sqldbm_diff_results:
        with open(result, "r") as file:
            file_as_string = file.read().replace("\n", "")
            object_type = get_object_type_from_sql(file_as_string).lower()

            if object_type == "procedure" or object_type == "view":
                result_file_name = result.split("/")[-1]
                previous_sql_version_path = os.path.join(
                    temp_dir_path, result_file_name
                )

                execute(
                    command=GIT_SHOW_COMMAND.format(
                        path=result, target_dir=previous_sql_version_path
                    ),
                    multi_statement=True,
                )

                # If file is not empty - i.e. file exists in main branch
                if os.stat(previous_sql_version_path).st_size > 0:
                    logging.info(
                        f"üîÑ Storing the rollback version of the stateless object [{result}] from the main branch."
                    )
                    stateless_rollback_results.append(previous_sql_version_path)
    return stateless_rollback_results, temp_dir_path


def deploy(deploy_type: str, mode: str):

    """
    Given an object deploy_type (see below for valid args)...

        1. Execute `git diff...` on their respective directory;
        2. Read SQL code from resulting scripts, concatenate path if more than 1;
        3. Package SQL code into Snowflake Lambda config dictionary from template;
        4. Invoke Snowflake Lambda with config dictionary.
    Given the rollback deploy_type...

        1. Execute `git diff...` in the rollbacks directory, concatenate path if more than 1;
        2. Execute `git diff...` in stateless object SqlDBM directories (Views/ and procedures/)
            2a. If the object has a previous version in the main branch, retrieve and concatenate path.
            2b. If the object does not have a previous version in the main branch, ignore.
        3. Package SQL code into Snowflake Lambda config dictionary from template;
        4. Invoke Snowflake Lambda with config dictionary.
    Program exits if deploy_type of 'tables' is provided.

    Args:
        deploy_type: The type of object you want to deploy, valid values [migrations, procedures, streams, views, tasks, tables, rollback]

    Returns:
        result str: The output from snowflake after deploying

    """
    stateless_diff_results = []
    temp_dir_path = None
    MIGRATIONS_DIR = get_common_var(EnvVars.MIGRATIONS_DIR)
    ROLLBACKS_DIR = get_common_var(EnvVars.ROLLBACKS_DIR)
    DDL_DIR = get_common_var(EnvVars.DDL_DIR)
    database = get_common_var(EnvVars.DATABASE)
    team = get_common_var(EnvVars.TEAM)

    use_main = mode == "squash_diff"  # Determine value of use_main based on mode

    if deploy_type == "tables":
        logging.info("üí• Tables cannot be deployed here.")
        sys.exit(1)
    if deploy_type == "migrations":
        diff_results = execute_git_diff(MIGRATIONS_DIR, use_main=use_main)
    if deploy_type == "rollback":
        diff_results = execute_git_diff(ROLLBACKS_DIR, use_main=use_main)
        stateless_diff_results, temp_dir_path = get_stateless_object_sql(
            use_main=use_main
        )
        diff_results.extend(stateless_diff_results)

    if deploy_type == "views":
        deploy_type = deploy_type.title()

        sqldbm_dir = os.path.join(DDL_DIR, deploy_type)
        diff_results = execute_git_diff(sqldbm_dir, use_main=use_main)

    result = ""
    if diff_results:
        snowflake_role = generate_role_name(database, team)
        logging.info(
            f"‚ùÑÔ∏è Deploying using Snowflake role [{snowflake_role}] in Snowflake database [ADW_{database}]"
        )

        sql_queries = get_sql_statements(diff_results)

        logging.info("üë∑‚Äç Deploying the following object(s)...")
        for diff_object in diff_results:
            logging.info(f"\t{diff_object}")

        result = call_snowflake(sql_queries=sql_queries)

    else:
        action = "deploy" if deploy_type != "rollback" else "rollback"
        logging.info(f"üì≠ Nothing to {action}!\n")

    if stateless_diff_results:
        shutil.rmtree(temp_dir_path)

    return result
